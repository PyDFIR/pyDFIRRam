{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>This site contains the project documentation for the <code>pyDFIRRam</code> project, an API to use Volatility</p>"},{"location":"#table-of-contents","title":"Table of contents","text":"<p>The documentation follows the best practice for project documentation as described by Daniele Procida in the Di\u00e1taxis documentation framework and consists of four separate parts:</p> <ol> <li>Tutorials</li> <li>How-To Guides</li> <li>Reference</li> <li>Explanation</li> </ol> <p>Quickly find what you're looking for depending on your use case by looking at the different pages.</p>"},{"location":"explanation/explanation/","title":"Explanation","text":"<p>The primary goal of this project is to develop a simple API for Volatility that facilitates orchestration and scripting. This approach allows users to focus on the data itself rather than solely on the output. By improving the representation of data beyond the command line interface (CLI), the project opens up new possibilities for data interpretation and analysis.</p> <p>Through this API, users can engage with the data in more intuitive and insightful ways, enabling a deeper understanding and more thorough examination of the information. This shift from traditional CLI outputs to a more versatile and user-friendly interface is designed to enhance the overall experience and effectiveness of memory analysis tasks.</p>"},{"location":"guide/guide/","title":"How-to Guide for pyDFIRRam","text":""},{"location":"guide/guide/#introduction","title":"Introduction","text":"<p>Welcome to the How-to Guide for pyDFIRRam, a Python wrapper for the Volatility framework. This guide will help you get started with the package, configure it, and perform common tasks.</p>"},{"location":"guide/guide/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Getting Started</li> </ol>"},{"location":"guide/guide/#getting-started","title":"Getting Started","text":""},{"location":"guide/guide/#prerequisite","title":"Prerequisite","text":"<ul> <li>Python3.10</li> </ul>"},{"location":"guide/guide/#installation","title":"Installation","text":"<p>To install pyDFIRRam, use pip: <pre><code>pip install pydfirram\n</code></pre></p>"},{"location":"guide/guide/#basic-usage","title":"Basic Usage","text":"<pre><code>from pydfirram.modules.windows import Windws\nwrap = Windows(\"dmp.raw\")\n\ndata = wrap.&lt;plugins&gt;().&lt;rendering&gt;()\n</code></pre>"},{"location":"guide/test/","title":"Test Documentation","text":""},{"location":"guide/test/#project-structure","title":"Project Structure","text":"<p>The project is organized as follows: <pre><code>.\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 config.py\n\u251c\u2500\u2500 data\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 dump.raw\n\u251c\u2500\u2500 test_core_base.py\n\u251c\u2500\u2500 test_core_rendering.py\n\u2514\u2500\u2500 test_volatility_windows_function.py\n</code></pre></p>"},{"location":"guide/test/#files-description","title":"Files Description","text":"<ul> <li> <p>config.py   This file contains configuration settings. You need to set the path of your dump file here before running the tests.</p> </li> <li> <p>test_core_base.py   This script tests the core functionalities used in <code>pydfirram/core/base.py</code>.</p> </li> <li> <p>test_core_rendering.py   This script tests the core functionalities used in <code>pydfirram/core/renderer.py</code>.</p> </li> <li> <p>test_volatility_windows_function.py   This script tests all(Not All configuration an plugins for the moment) plugins of Volatility.</p> </li> </ul>"},{"location":"guide/test/#test-data","title":"Test Data","text":"<ul> <li>data/dump.raw   This is where your test dump file should be located.</li> </ul>"},{"location":"guide/test/#running-the-tests","title":"Running the Tests","text":""},{"location":"guide/test/#prerequisites","title":"Prerequisites","text":"<ol> <li> <p>Download the Windows XP image from the Volatility Foundation:    Win XP Image.</p> </li> <li> <p>Extract the downloaded image and place it in the <code>data</code> directory. Rename it to <code>dump.raw</code>.</p> </li> </ol>"},{"location":"guide/test/#configuration","title":"Configuration","text":"<ol> <li>Open <code>config.py</code>.</li> <li>Set the path of your dump file in the configuration.</li> </ol>"},{"location":"guide/test/#running-the-tests_1","title":"Running the Tests","text":"<p>To run the tests, use the following command: <pre><code>pytest\n</code></pre></p>"},{"location":"guide/test/#notes","title":"Notes","text":"<ul> <li>The current tests only support Windows architectures. Linux architectures are not supported yet.</li> </ul>"},{"location":"reference/base/","title":"Base","text":""},{"location":"reference/base/#base","title":"Base","text":"<p>Create generic volatility3 OS wrappers.</p> <p>This module provides a way to interact with Volatility3 plugins in a more abstract way. It allows to automatically get all available plugins for a specific OS and run them with the required arguments.</p> Example <p>The module can be used as follows:</p> <pre><code>$ python3\n&gt;&gt;&gt; from pydfirram.core.base import Generic, OperatingSystem\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; os = OperatingSystem.WINDOWS\n&gt;&gt;&gt; dumpfile = Path(\"tests/data/dump.raw\")\n&gt;&gt;&gt; generic = Generic(os, dumpfile)\n&gt;&gt;&gt; plugin = generic.get_plugin(\"Banners\")\n&gt;&gt;&gt; generic.run_plugin(plugin)\n</code></pre> Example <p>Or it can be used as follow :</p> <pre><code>$ python3\n&gt;&gt;&gt; from pydfirram.core.base import Generic, OperatingSystem\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; os = OperatingSystem.WINDOWS\n&gt;&gt;&gt; dumpfile = Path(\"tests/data/dump.raw\")\n&gt;&gt;&gt; generic = Generic(dumpfile)\n&gt;&gt;&gt; plugin = generic.pslist().to_df()\n&gt;&gt;&gt; print(plugin)\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.Context","title":"<code>Context</code>","text":"<p>Context for a volatility3 plugin.</p> <p>Attributes:</p> Name Type Description <code>os</code> <p>OperatingSystem: The operating system.</p> <code>dump_file</code> <p>Path: The dump file path.</p> <code>context</code> <p>V3Context: The volatility3 context.</p> <code>plugin</code> <p>PluginEntry: The plugin entry.</p> Constants <p>KEY_LAYER_STACKER: str: The layer stacker key. KEY_STACKERS: str: The stackers key. KEY_SINGLE_LOCATION: str: The single location key.</p> Source code in <code>pydfirram/core/base.py</code> <pre><code>class Context():\n    \"\"\"Context for a volatility3 plugin.\n\n    Attributes:\n        os: OperatingSystem: The operating system.\n        dump_file: Path: The dump file path.\n        context: V3Context: The volatility3 context.\n        plugin: PluginEntry: The plugin entry.\n\n    Constants:\n        KEY_LAYER_STACKER: str: The layer stacker key.\n        KEY_STACKERS: str: The stackers key.\n        KEY_SINGLE_LOCATION: str: The single location key.\n    \"\"\"\n\n    KEY_LAYER_STACKER = \"automagic.LayerStacker\"\n    KEY_STACKERS = f\"{KEY_LAYER_STACKER}.stackers\"\n    KEY_SINGLE_LOCATION = f\"{KEY_LAYER_STACKER}.single_location\"\n\n    def __init__(\n        self,\n        operating_system: OperatingSystem,\n        dump_file: Path,\n        plugin: PluginEntry,\n    ):\n        \"\"\"Initializes a context.\n\n        Args:\n            operating_system (OperatingSystem): The operating system.\n            dump_file (Path): The dump file path.\n            plugin (PluginEntry): The plugin entry.\n        \"\"\"\n        self.os = operating_system\n        self.dump_file = dump_file\n        self.context = V3Context()\n        self.plugin = plugin\n        self.automag: Any = None\n\n    def set_context(self) -&gt; None:\n        \"\"\" setup the current context \"\"\"\n        dump_file_location = self.get_dump_file_location()\n        self.context.config[self.KEY_STACKERS] = self.os_stackers()\n        self.context.config[self.KEY_SINGLE_LOCATION] = dump_file_location\n\n    def set_automagic(self) -&gt; None:\n        \"\"\" setup the automagics \"\"\"\n        self.automag = self.automagics()\n\n    def build(self) -&gt; V3PluginInterface:\n        \"\"\"Build a basic context for the provided plugin.\n\n        Returns:\n            interfaces.plugins.PluginInterface: The built plugin interface.\n\n        Raises:\n            V3UnsatisfiedException: If the plugin cannot be built.\n        \"\"\"\n        plugin = self.plugin.interface\n        base_config_path = \"plugins\"\n        file_handler = create_file_handler(os.getcwd())\n        try:\n            # Construct the plugin, clever magic figures out how to\n            # fulfill each requirement that might not be fulfilled\n            # @notes\n            # - As many volatility3 internals, some of the argument mismatch\n            # because type awaiting by the framework is, for exemple,\n            # `type[PluginInterface]` and we give a `PluginInterface` wich\n            # is the same thing...So, lets cast to `Any` to avoid embrouille\n            constructed = v3_construct_plugin(\n                self.context,\n                self.automag,\n                cast(Any, plugin),\n                base_config_path,\n                None,  # no progress callback for now\n                file_handler,\n            )\n        except V3UnsatisfiedException as err:\n            logger.error(f\"Failed to build plugin: {err}\")\n            raise err\n        return constructed\n\n    def add_arguments(\n        self,\n        context: V3Context,\n        kwargs: dict[str, Any]\n    ) -&gt; V3Context:\n        \"\"\"\n        Handle keyword arguments and set them as context config attributes.\n\n        Args:\n            kwargs (dict[str, Any]): The keyword arguments.\n\n        Raises:\n            AttributeError: If the attribute does not exist.\n        \"\"\"\n        for k, v in kwargs.items():\n            context.config[k] = v\n        return context\n\n\n    def get_available_automagics(self) -&gt; list[V3AutomagicInterface]:\n        \"\"\"Returns a list of available volatility3 automagics.\n\n        Returns:\n            List[V3AutomagicInterface]: A list of available automagics.\n        \"\"\"\n        return cast(\n            list[V3AutomagicInterface],\n            v3_automagic_available(self.context),\n        )\n\n    def automagics(self) -&gt; list[V3AutomagicInterface]:\n        \"\"\"Returns a list of volatility3 automagics.\n\n        Returns:\n            List[V3AutomagicInterface]: A list of automagics.\n\n        Raises:\n            V3UnsatisfiedException: If no automagic can be chosen.\n        \"\"\"\n        available_automagics = self.get_available_automagics()\n        # @notes\n        # It seems that `choose_automagic` require weird typing information\n        # that should match what we give to this bastard, but it's not\n        # since, for example, our `PluginInterface` do not match the\n        # `type[PluginInterface]` awaited...even if its the same type :pouce:\n        # So, let's cast all argument to Any to avoid typing collision\n        return cast(\n            list[V3AutomagicInterface],\n            v3_automagic_choose(\n                cast(Any, available_automagics),\n                cast(Any, self.plugin.interface),\n            ),\n        )\n\n    def os_stackers(self) -&gt; list[V3AutomagicInterface]:\n        \"\"\"Returns a list of stackers for the OS.\n\n        Returns:\n            List[V3AutomagicInterface]: A list of (volatility3) stackers.\n        \"\"\"\n        return cast(\n            list[V3AutomagicInterface],\n            v3_choose_os_stackers(cast(Any,self.plugin.interface)),\n        )\n\n    def get_dump_file_location(self) -&gt; str:\n        \"\"\"Returns the dump file location.\n\n        Returns:\n            str: The dump file location formatted as a URL.\n        \"\"\"\n        return \"file://\" + self.dump_file.absolute().as_posix()\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.Context.__init__","title":"<code>__init__(operating_system, dump_file, plugin)</code>","text":"<p>Initializes a context.</p> <p>Parameters:</p> Name Type Description Default <code>operating_system</code> <code>OperatingSystem</code> <p>The operating system.</p> required <code>dump_file</code> <code>Path</code> <p>The dump file path.</p> required <code>plugin</code> <code>PluginEntry</code> <p>The plugin entry.</p> required Source code in <code>pydfirram/core/base.py</code> <pre><code>def __init__(\n    self,\n    operating_system: OperatingSystem,\n    dump_file: Path,\n    plugin: PluginEntry,\n):\n    \"\"\"Initializes a context.\n\n    Args:\n        operating_system (OperatingSystem): The operating system.\n        dump_file (Path): The dump file path.\n        plugin (PluginEntry): The plugin entry.\n    \"\"\"\n    self.os = operating_system\n    self.dump_file = dump_file\n    self.context = V3Context()\n    self.plugin = plugin\n    self.automag: Any = None\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.Context.add_arguments","title":"<code>add_arguments(context, kwargs)</code>","text":"<p>Handle keyword arguments and set them as context config attributes.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict[str, Any]</code> <p>The keyword arguments.</p> required <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the attribute does not exist.</p> Source code in <code>pydfirram/core/base.py</code> <pre><code>def add_arguments(\n    self,\n    context: V3Context,\n    kwargs: dict[str, Any]\n) -&gt; V3Context:\n    \"\"\"\n    Handle keyword arguments and set them as context config attributes.\n\n    Args:\n        kwargs (dict[str, Any]): The keyword arguments.\n\n    Raises:\n        AttributeError: If the attribute does not exist.\n    \"\"\"\n    for k, v in kwargs.items():\n        context.config[k] = v\n    return context\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.Context.automagics","title":"<code>automagics()</code>","text":"<p>Returns a list of volatility3 automagics.</p> <p>Returns:</p> Type Description <code>list[AutomagicInterface]</code> <p>List[V3AutomagicInterface]: A list of automagics.</p> <p>Raises:</p> Type Description <code>UnsatisfiedException</code> <p>If no automagic can be chosen.</p> Source code in <code>pydfirram/core/base.py</code> <pre><code>def automagics(self) -&gt; list[V3AutomagicInterface]:\n    \"\"\"Returns a list of volatility3 automagics.\n\n    Returns:\n        List[V3AutomagicInterface]: A list of automagics.\n\n    Raises:\n        V3UnsatisfiedException: If no automagic can be chosen.\n    \"\"\"\n    available_automagics = self.get_available_automagics()\n    # @notes\n    # It seems that `choose_automagic` require weird typing information\n    # that should match what we give to this bastard, but it's not\n    # since, for example, our `PluginInterface` do not match the\n    # `type[PluginInterface]` awaited...even if its the same type :pouce:\n    # So, let's cast all argument to Any to avoid typing collision\n    return cast(\n        list[V3AutomagicInterface],\n        v3_automagic_choose(\n            cast(Any, available_automagics),\n            cast(Any, self.plugin.interface),\n        ),\n    )\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.Context.build","title":"<code>build()</code>","text":"<p>Build a basic context for the provided plugin.</p> <p>Returns:</p> Type Description <code>PluginInterface</code> <p>interfaces.plugins.PluginInterface: The built plugin interface.</p> <p>Raises:</p> Type Description <code>UnsatisfiedException</code> <p>If the plugin cannot be built.</p> Source code in <code>pydfirram/core/base.py</code> <pre><code>def build(self) -&gt; V3PluginInterface:\n    \"\"\"Build a basic context for the provided plugin.\n\n    Returns:\n        interfaces.plugins.PluginInterface: The built plugin interface.\n\n    Raises:\n        V3UnsatisfiedException: If the plugin cannot be built.\n    \"\"\"\n    plugin = self.plugin.interface\n    base_config_path = \"plugins\"\n    file_handler = create_file_handler(os.getcwd())\n    try:\n        # Construct the plugin, clever magic figures out how to\n        # fulfill each requirement that might not be fulfilled\n        # @notes\n        # - As many volatility3 internals, some of the argument mismatch\n        # because type awaiting by the framework is, for exemple,\n        # `type[PluginInterface]` and we give a `PluginInterface` wich\n        # is the same thing...So, lets cast to `Any` to avoid embrouille\n        constructed = v3_construct_plugin(\n            self.context,\n            self.automag,\n            cast(Any, plugin),\n            base_config_path,\n            None,  # no progress callback for now\n            file_handler,\n        )\n    except V3UnsatisfiedException as err:\n        logger.error(f\"Failed to build plugin: {err}\")\n        raise err\n    return constructed\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.Context.get_available_automagics","title":"<code>get_available_automagics()</code>","text":"<p>Returns a list of available volatility3 automagics.</p> <p>Returns:</p> Type Description <code>list[AutomagicInterface]</code> <p>List[V3AutomagicInterface]: A list of available automagics.</p> Source code in <code>pydfirram/core/base.py</code> <pre><code>def get_available_automagics(self) -&gt; list[V3AutomagicInterface]:\n    \"\"\"Returns a list of available volatility3 automagics.\n\n    Returns:\n        List[V3AutomagicInterface]: A list of available automagics.\n    \"\"\"\n    return cast(\n        list[V3AutomagicInterface],\n        v3_automagic_available(self.context),\n    )\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.Context.get_dump_file_location","title":"<code>get_dump_file_location()</code>","text":"<p>Returns the dump file location.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The dump file location formatted as a URL.</p> Source code in <code>pydfirram/core/base.py</code> <pre><code>def get_dump_file_location(self) -&gt; str:\n    \"\"\"Returns the dump file location.\n\n    Returns:\n        str: The dump file location formatted as a URL.\n    \"\"\"\n    return \"file://\" + self.dump_file.absolute().as_posix()\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.Context.os_stackers","title":"<code>os_stackers()</code>","text":"<p>Returns a list of stackers for the OS.</p> <p>Returns:</p> Type Description <code>list[AutomagicInterface]</code> <p>List[V3AutomagicInterface]: A list of (volatility3) stackers.</p> Source code in <code>pydfirram/core/base.py</code> <pre><code>def os_stackers(self) -&gt; list[V3AutomagicInterface]:\n    \"\"\"Returns a list of stackers for the OS.\n\n    Returns:\n        List[V3AutomagicInterface]: A list of (volatility3) stackers.\n    \"\"\"\n    return cast(\n        list[V3AutomagicInterface],\n        v3_choose_os_stackers(cast(Any,self.plugin.interface)),\n    )\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.Context.set_automagic","title":"<code>set_automagic()</code>","text":"<p>setup the automagics</p> Source code in <code>pydfirram/core/base.py</code> <pre><code>def set_automagic(self) -&gt; None:\n    \"\"\" setup the automagics \"\"\"\n    self.automag = self.automagics()\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.Context.set_context","title":"<code>set_context()</code>","text":"<p>setup the current context</p> Source code in <code>pydfirram/core/base.py</code> <pre><code>def set_context(self) -&gt; None:\n    \"\"\" setup the current context \"\"\"\n    dump_file_location = self.get_dump_file_location()\n    self.context.config[self.KEY_STACKERS] = self.os_stackers()\n    self.context.config[self.KEY_SINGLE_LOCATION] = dump_file_location\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.Generic","title":"<code>Generic</code>","text":"<p>Generic OS wrapper to be used with volatility3</p> <p>This class provides a way to interact with volatility3 plugins in a more abstract way. It allows to automatically get all available plugins for a specific OS and run them with the required arguments.</p> <p>It aims to be inherited by specific OS wrappers like Windows, Linux or MacOS.</p> <p>Attributes:</p> Name Type Description <code>os</code> <code>OperatingSystem</code> <p>The operating system.</p> <code>plugins</code> <code>List[PluginEntry]</code> <p>The list of plugins.</p> <code>dump_file</code> <code>Path</code> <p>The dump file path.</p> <code>context</code> <code>Context</code> <p>The context.</p> Source code in <code>pydfirram/core/base.py</code> <pre><code>class Generic():\n    \"\"\"Generic OS wrapper to be used with volatility3\n\n    This class provides a way to interact with volatility3 plugins in a more\n    abstract way. It allows to automatically get all available plugins for a\n    specific OS and run them with the required arguments.\n\n    It aims to be inherited by specific OS wrappers like Windows, Linux or\n    MacOS.\n\n    Attributes:\n        os (OperatingSystem): The operating system.\n        plugins (List[PluginEntry]): The list of plugins.\n        dump_file (Path): The dump file path.\n        context (Context): The context.\n    \"\"\"\n\n    #---\n    # Magic methods\n    #---\n\n    def __init__(self, operating_system: OperatingSystem, dump_file: Path):\n        \"\"\"Initializes a generic OS.\n\n        Automatically get all available Volatility3 plugins for the OS.\n\n        Args:\n            operating_system (OperatingSystem): The operating system.\n            dump_file (Path): The dump file path.\n\n        Raises:\n            FileNotFoundError: If the dump file does not exist.\n        \"\"\"\n        self.validate_dump_file(dump_file)\n        self.os = operating_system\n        self.plugins: list[PluginEntry] = self.get_all_plugins()\n        self.dump_file = dump_file\n        self.context: Optional[Context] = None\n        self.temp_data = None\n        self.tmp_plugin: Optional[PluginEntry] = None\n\n        logger.info(f\"Generic OS initialized: {self.os}\")\n\n    def __getattr__(\n        self,\n        key: str,\n        **kwargs: dict[str, Any]\n    ) -&gt; Callable[...,Renderer]:\n        \"\"\"\n        Handle attribute access for commands.\n\n        This method is called when an attribute that\n        matches a command name is accessed. It returns a lambda function\n        that calls the __run_commands method with the corresponding key.\n\n        :param key: The attribute name (command name).\n        :type key: str\n        :param args: Positional arguments for the method call.\n        :param kwargs: Keyword arguments for the method call.\n        :return: A class of Renderer that is the result of a lambda\n        function that executes the __run_commands method for the given key.\n        \"\"\"\n        key = key.lower()\n        try:\n            plugin: PluginEntry = self.get_plugin(key)\n        except Exception as exc:\n            raise ValueError(f\"Unable to handle {key}\") from exc\n        def parse_data_function(**kwargs: dict[str,Any]) -&gt; Renderer:\n            return Renderer(\n                data    = self.run_plugin(plugin,**kwargs)\n            )\n        return parse_data_function\n\n    #---\n    # Internals methods\n    #---\n\n    def _get_plugins_list(self) -&gt; dict[str,Any]:\n        \"\"\"Get a list of available volatility3 plugins for the OS.\n\n        Returns:\n            dict[str,Any]: A dictionary of plugins.\n        \"\"\"\n        failures = v3_framework_import_files(\n            base_module     = v3_framework_plugins_mod,\n            ignore_errors   = True\n        )\n        if failures:\n            logger.warning(f\"Failed to import some plugins: {failures}\")\n        return cast(dict[str,Any], v3_framework_list_plugins())\n\n    def _parse_plugins_list(\n        self,\n        plugin_list: dict[str, Any],\n    ) -&gt; list[PluginEntry]:\n        \"\"\"Parse the list of available volatility3 plugins.\n\n        The plugin list is a dictionary where the key is the plugin name\n        and the value is the plugin interface.\n\n        Args:\n            plugin_list (Dict[str, Any]): The plugin list.\n\n        Returns:\n            List[PluginEntry]: A list of PluginEntry.\n        \"\"\"\n        parsed: list[PluginEntry] = []\n        for plugin in plugin_list:\n            interface = plugin_list[plugin]\n            elements = plugin.split(\".\")\n            platform = elements[0]\n            name = elements[-1]\n            name = name.lower()\n            if platform not in OperatingSystem.to_list():\n                type_ = PluginType.GENERIC\n            elif platform == self.os.value:\n                type_ = PluginType.SPECIFIC\n            else:\n                continue\n            parsed.append(\n                PluginEntry(type_, name, interface),\n            )\n        logger.info(f\"Found {len(parsed)} plugins for {self.os}\")\n        return parsed\n\n    #---\n    # Public methods\n    #---\n\n    # (todo) : more explicit return type\n    def run_plugin(\n        self,\n        plugin: PluginEntry,\n        **kwargs: dict[str,Any],\n    ) -&gt; Any:\n        \"\"\"Run a volatility3 plugin with the given arguments.\n\n        Args:\n            plugin (PluginEntry): The plugin entry.\n            **kwargs (Any): The keyword arguments.\n\n        Returns:\n            Any: The result of the plugin.\n\n        Raises:\n            ValueError: If the context is not built.\n        \"\"\"\n        # (todo) : move `context.set_*()` in `Context.__init__()` ?\n        self.context = Context(self.os, self.dump_file, plugin) # type: ignore\n        self.context.set_automagic()\n        self.context.set_context()\n        builded_context = self.context.build() # type: ignore\n        if kwargs:\n            runable_context = self.context.add_arguments(builded_context,kwargs)\n        else:\n            runable_context = builded_context\n        if self.context is None:\n            raise ValueError(\"Context not built.\")\n        return runable_context.run()\n\n    def validate_dump_file(self, dump_file: Path) -&gt; bool:\n        \"\"\"Validate dump file location.\n\n        Args:\n            dump_file (Path): The dump file path.\n\n        Returns:\n            bool: True if the file exists.\n\n        Raises:\n            FileNotFoundError: If the file does not exist.\n        \"\"\"\n        if dump_file.is_file():\n            return True\n        raise FileNotFoundError(f\"The file {dump_file} does not exist.\")\n\n    def get_plugin(self, name: str) -&gt; PluginEntry:\n        \"\"\"Fetches a plugin by its name from the list of plugins.\n\n        Args:\n            name (str): The plugin name.\n\n        Returns:\n            PluginEntry: The plugin entry.\n\n        Raises:\n            ValueError: If the plugin is not found.\n        \"\"\"\n        name = name.lower()\n        for plugin in self.plugins:\n            if plugin.name == name:\n                return plugin\n        raise ValueError(f\"Plugin {name} not found for {self.os}\")\n\n    def get_all_plugins(self) -&gt; list[PluginEntry]:\n        \"\"\"Get all available plugins for the specified OS.\n\n        Returns:\n            List[PluginEntry]: A list of plugins for the specified OS\n            or all available plugins if the OS is not supported.\n\n        Raises:\n            ValueError: If the plugin is not found.\n        \"\"\"\n        plugin_list = self._get_plugins_list()\n        parsed_plugins = self._parse_plugins_list(plugin_list)\n        return parsed_plugins\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.Generic.__getattr__","title":"<code>__getattr__(key, **kwargs)</code>","text":"<p>Handle attribute access for commands.</p> <p>This method is called when an attribute that matches a command name is accessed. It returns a lambda function that calls the __run_commands method with the corresponding key.</p> <p>:param key: The attribute name (command name). :type key: str :param args: Positional arguments for the method call. :param kwargs: Keyword arguments for the method call. :return: A class of Renderer that is the result of a lambda function that executes the __run_commands method for the given key.</p> Source code in <code>pydfirram/core/base.py</code> <pre><code>def __getattr__(\n    self,\n    key: str,\n    **kwargs: dict[str, Any]\n) -&gt; Callable[...,Renderer]:\n    \"\"\"\n    Handle attribute access for commands.\n\n    This method is called when an attribute that\n    matches a command name is accessed. It returns a lambda function\n    that calls the __run_commands method with the corresponding key.\n\n    :param key: The attribute name (command name).\n    :type key: str\n    :param args: Positional arguments for the method call.\n    :param kwargs: Keyword arguments for the method call.\n    :return: A class of Renderer that is the result of a lambda\n    function that executes the __run_commands method for the given key.\n    \"\"\"\n    key = key.lower()\n    try:\n        plugin: PluginEntry = self.get_plugin(key)\n    except Exception as exc:\n        raise ValueError(f\"Unable to handle {key}\") from exc\n    def parse_data_function(**kwargs: dict[str,Any]) -&gt; Renderer:\n        return Renderer(\n            data    = self.run_plugin(plugin,**kwargs)\n        )\n    return parse_data_function\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.Generic.__init__","title":"<code>__init__(operating_system, dump_file)</code>","text":"<p>Initializes a generic OS.</p> <p>Automatically get all available Volatility3 plugins for the OS.</p> <p>Parameters:</p> Name Type Description Default <code>operating_system</code> <code>OperatingSystem</code> <p>The operating system.</p> required <code>dump_file</code> <code>Path</code> <p>The dump file path.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the dump file does not exist.</p> Source code in <code>pydfirram/core/base.py</code> <pre><code>def __init__(self, operating_system: OperatingSystem, dump_file: Path):\n    \"\"\"Initializes a generic OS.\n\n    Automatically get all available Volatility3 plugins for the OS.\n\n    Args:\n        operating_system (OperatingSystem): The operating system.\n        dump_file (Path): The dump file path.\n\n    Raises:\n        FileNotFoundError: If the dump file does not exist.\n    \"\"\"\n    self.validate_dump_file(dump_file)\n    self.os = operating_system\n    self.plugins: list[PluginEntry] = self.get_all_plugins()\n    self.dump_file = dump_file\n    self.context: Optional[Context] = None\n    self.temp_data = None\n    self.tmp_plugin: Optional[PluginEntry] = None\n\n    logger.info(f\"Generic OS initialized: {self.os}\")\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.Generic.get_all_plugins","title":"<code>get_all_plugins()</code>","text":"<p>Get all available plugins for the specified OS.</p> <p>Returns:</p> Type Description <code>list[PluginEntry]</code> <p>List[PluginEntry]: A list of plugins for the specified OS</p> <code>list[PluginEntry]</code> <p>or all available plugins if the OS is not supported.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the plugin is not found.</p> Source code in <code>pydfirram/core/base.py</code> <pre><code>def get_all_plugins(self) -&gt; list[PluginEntry]:\n    \"\"\"Get all available plugins for the specified OS.\n\n    Returns:\n        List[PluginEntry]: A list of plugins for the specified OS\n        or all available plugins if the OS is not supported.\n\n    Raises:\n        ValueError: If the plugin is not found.\n    \"\"\"\n    plugin_list = self._get_plugins_list()\n    parsed_plugins = self._parse_plugins_list(plugin_list)\n    return parsed_plugins\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.Generic.get_plugin","title":"<code>get_plugin(name)</code>","text":"<p>Fetches a plugin by its name from the list of plugins.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The plugin name.</p> required <p>Returns:</p> Name Type Description <code>PluginEntry</code> <code>PluginEntry</code> <p>The plugin entry.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the plugin is not found.</p> Source code in <code>pydfirram/core/base.py</code> <pre><code>def get_plugin(self, name: str) -&gt; PluginEntry:\n    \"\"\"Fetches a plugin by its name from the list of plugins.\n\n    Args:\n        name (str): The plugin name.\n\n    Returns:\n        PluginEntry: The plugin entry.\n\n    Raises:\n        ValueError: If the plugin is not found.\n    \"\"\"\n    name = name.lower()\n    for plugin in self.plugins:\n        if plugin.name == name:\n            return plugin\n    raise ValueError(f\"Plugin {name} not found for {self.os}\")\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.Generic.run_plugin","title":"<code>run_plugin(plugin, **kwargs)</code>","text":"<p>Run a volatility3 plugin with the given arguments.</p> <p>Parameters:</p> Name Type Description Default <code>plugin</code> <code>PluginEntry</code> <p>The plugin entry.</p> required <code>**kwargs</code> <code>Any</code> <p>The keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The result of the plugin.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the context is not built.</p> Source code in <code>pydfirram/core/base.py</code> <pre><code>def run_plugin(\n    self,\n    plugin: PluginEntry,\n    **kwargs: dict[str,Any],\n) -&gt; Any:\n    \"\"\"Run a volatility3 plugin with the given arguments.\n\n    Args:\n        plugin (PluginEntry): The plugin entry.\n        **kwargs (Any): The keyword arguments.\n\n    Returns:\n        Any: The result of the plugin.\n\n    Raises:\n        ValueError: If the context is not built.\n    \"\"\"\n    # (todo) : move `context.set_*()` in `Context.__init__()` ?\n    self.context = Context(self.os, self.dump_file, plugin) # type: ignore\n    self.context.set_automagic()\n    self.context.set_context()\n    builded_context = self.context.build() # type: ignore\n    if kwargs:\n        runable_context = self.context.add_arguments(builded_context,kwargs)\n    else:\n        runable_context = builded_context\n    if self.context is None:\n        raise ValueError(\"Context not built.\")\n    return runable_context.run()\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.Generic.validate_dump_file","title":"<code>validate_dump_file(dump_file)</code>","text":"<p>Validate dump file location.</p> <p>Parameters:</p> Name Type Description Default <code>dump_file</code> <code>Path</code> <p>The dump file path.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the file exists.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file does not exist.</p> Source code in <code>pydfirram/core/base.py</code> <pre><code>def validate_dump_file(self, dump_file: Path) -&gt; bool:\n    \"\"\"Validate dump file location.\n\n    Args:\n        dump_file (Path): The dump file path.\n\n    Returns:\n        bool: True if the file exists.\n\n    Raises:\n        FileNotFoundError: If the file does not exist.\n    \"\"\"\n    if dump_file.is_file():\n        return True\n    raise FileNotFoundError(f\"The file {dump_file} does not exist.\")\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.OperatingSystem","title":"<code>OperatingSystem</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Supported operating system.</p> <p>Attributes:</p> Name Type Description <code>WINDOWS</code> <p>Windows OS.</p> <code>LINUX</code> <p>Linux OS.</p> <code>MACOS</code> <p>MacOS OS.</p> Source code in <code>pydfirram/core/base.py</code> <pre><code>class OperatingSystem(Enum):\n    \"\"\"Supported operating system.\n\n    Attributes:\n        WINDOWS: Windows OS.\n        LINUX: Linux OS.\n        MACOS: MacOS OS.\n    \"\"\"\n\n    WINDOWS = \"windows\"\n    LINUX = \"linux\"\n    MACOS = \"mac\"\n\n    @staticmethod\n    def to_list() -&gt; list[str]:\n        \"\"\"Returns a list of supported operating systems.\n        Returns:\n            List[str]: List of supported operating systems.\n        \"\"\"\n        return [os.value for os in OperatingSystem]\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.OperatingSystem.to_list","title":"<code>to_list()</code>  <code>staticmethod</code>","text":"<p>Returns a list of supported operating systems. Returns:     List[str]: List of supported operating systems.</p> Source code in <code>pydfirram/core/base.py</code> <pre><code>@staticmethod\ndef to_list() -&gt; list[str]:\n    \"\"\"Returns a list of supported operating systems.\n    Returns:\n        List[str]: List of supported operating systems.\n    \"\"\"\n    return [os.value for os in OperatingSystem]\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.PluginEntry","title":"<code>PluginEntry</code>  <code>dataclass</code>","text":"<p>A plugin entry.</p> <p>The interface allows to directly interact with the plugin from volatility3 functions.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>PluginType</code> <p>PluginType: The plugin type.</p> <code>name</code> <code>str</code> <p>str: The plugin name.</p> <code>interface</code> <code>PluginInterface</code> <p>PluginInterface: The (volatility3) plugin interface.</p> Source code in <code>pydfirram/core/base.py</code> <pre><code>@dataclass\nclass PluginEntry():\n    \"\"\"A plugin entry.\n\n    The interface allows to directly interact with the plugin from\n    volatility3 functions.\n\n    Attributes:\n        type: PluginType: The plugin type.\n        name: str: The plugin name.\n        interface: PluginInterface: The (volatility3) plugin interface.\n    \"\"\"\n\n    type: PluginType\n    name: str\n    interface: V3PluginInterface\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Returns a string representation of the plugin entry.\"\"\"\n        return f\"PluginEntry({self.type}, {self.name}, {self.interface})\"\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.PluginEntry.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns a string representation of the plugin entry.</p> Source code in <code>pydfirram/core/base.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Returns a string representation of the plugin entry.\"\"\"\n    return f\"PluginEntry({self.type}, {self.name}, {self.interface})\"\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.PluginType","title":"<code>PluginType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>A volatiliry3 plugin type.</p> <p>Attributes:</p> Name Type Description <code>GENERIC</code> <p>A generic plugin, can be used with any OS.</p> <code>SPECIFIC</code> <p>An OS-specific plugin.</p> Source code in <code>pydfirram/core/base.py</code> <pre><code>class PluginType(Enum):\n    \"\"\"A volatiliry3 plugin type.\n\n    Attributes:\n        GENERIC: A generic plugin, can be used with any OS.\n        SPECIFIC: An OS-specific plugin.\n    \"\"\"\n\n    GENERIC = 1\n    SPECIFIC = 2\n</code></pre>"},{"location":"reference/handler/","title":"Handler","text":""},{"location":"reference/handler/#handler","title":"Handler","text":"<p>Provides a file handler class that saves files directly to disk.</p> <p>This module provides a file handler class that saves files directly to disk. It is used by the Volatility3 CLI to save files to disk.</p> Example <p>The file handler class can be used as follows:</p> <pre><code>$ python3\n&gt;&gt;&gt; from volatility3.cli import create_file_handler\n&gt;&gt;&gt; file_handler = create_file_handler(\"output\")\n&gt;&gt;&gt; file = file_handler(\"test.txt\")\n&gt;&gt;&gt; file.write(b\"Hello, world!\")\n&gt;&gt;&gt; file.close()\n</code></pre> Todo <ul> <li>For now, this module only provides a file handler class   that saves files directly to disk. In the future, it could   be extended to provide other file handlers as well.</li> </ul>"},{"location":"reference/handler/#pydfirram.core.handler.create_file_handler","title":"<code>create_file_handler(output_dir)</code>","text":"<p>Create a file handler class that saves files directly to disk.</p> <p>Parameters:</p> Name Type Description Default <code>output_dir</code> <code>str</code> <p>The directory where the files should be saved.               If None, raises a TypeError.</p> required <p>Returns:     type: A file handler class that saves files directly to disk.</p> Source code in <code>pydfirram/core/handler.py</code> <pre><code>def create_file_handler(output_dir: Optional[str]) -&gt; type:\n    \"\"\"Create a file handler class that saves files directly to disk.\n\n    Args:\n        output_dir (str): The directory where the files should be saved.\n                          If None, raises a TypeError.\n    Returns:\n        type: A file handler class that saves files directly to disk.\n    \"\"\"\n\n    class CLIFileHandler(V3FileHandlerInterface): # type: ignore\n        \"\"\"The FileHandler from Volatility3 CLI.\n        \"\"\"\n        def _get_final_filename(self) -&gt; str:\n            \"\"\"Gets the final filename for the saved file.\"\"\"\n            if output_dir is None:\n                raise TypeError(\"Output directory is not a string\")\n\n            os.makedirs(output_dir, exist_ok=True)\n            if self.preferred_filename is None:\n                raise TypeError(\"No preferred filename\")\n\n            pref_name_array = self.preferred_filename.split(\".\")\n\n            filename, extension = (\n                os.path.join(output_dir, \".\".join(pref_name_array[:-1])),\n                pref_name_array[-1],\n            )\n            output_filename = f\"{filename}.{extension}\"\n\n            if os.path.exists(output_filename):\n                os.remove(output_filename)\n\n            return output_filename\n\n        def close(self) -&gt; None:\n            \"\"\" V3FileHandlerInterface require to implement this method \"\"\"\n\n    class CLIDirectFileHandler(CLIFileHandler):\n        \"\"\"A file handler class that saves files directly to disk.\n        \"\"\"\n        def __init__(self, filename: str) -&gt; None:\n            fd, temp_name = tempfile.mkstemp(\n                suffix  = \".vol3\",\n                prefix  = \"tmp_\",\n                dir     = output_dir,\n            )\n\n            # allow `io.open()` without using `with` context\n            # pylint: disable=R1732\n            self._file = io.open(fd, mode=\"w+b\")\n            CLIFileHandler.__init__(self, filename) # type: ignore\n\n            for attr in dir(self._file):\n                if not attr.startswith(\"_\") and attr not in [\n                    \"closed\",\n                    \"close\",\n                    \"mode\",\n                    \"name\",\n                ]:\n                    setattr(self, attr, getattr(self._file, attr))\n\n            self._name = temp_name\n\n        def __getattr__(self, item: Any) -&gt; Any:\n            return getattr(self._file, item)\n\n        ## properties\n\n        @property\n        def closed(self) -&gt; bool:\n            \"\"\"Returns whether the file is closed.\"\"\"\n            return self._file.closed\n\n        @property\n        def mode(self) -&gt; str:\n            \"\"\"Returns the mode of the file.\"\"\"\n            return self._file.mode\n\n        @property\n        def name(self) -&gt; str:\n            \"\"\"Returns the name of the file.\"\"\"\n            return self._file.name\n\n        ## methods\n\n        def close(self) -&gt; None:\n            \"\"\"Closes and commits the file\n            by moving the temporary file to the correct name.\n            \"\"\"\n            # Don't overcommit\n            if self._file.closed:\n                return\n            self._file.close()\n            output_filename = self._get_final_filename()\n            os.rename(self._name, output_filename)\n\n    return CLIDirectFileHandler\n</code></pre>"},{"location":"reference/reference/","title":"Index","text":""},{"location":"reference/reference/#index-of-references","title":"Index of References","text":"<p>This index provides a structured overview of the various reference documentation pages for the project, using the Di\u00e1taxis framework. Each page focuses on different components and functionalities of the project.</p>"},{"location":"reference/reference/#documentation-pages","title":"Documentation Pages","text":""},{"location":"reference/reference/#base","title":"Base","text":"<p>This page details the foundational elements of the project. It includes core classes, functions, and their interactions.</p>"},{"location":"reference/reference/#handler","title":"Handler","text":"<p>The handler documentation covers the management of different processes within the project. It outlines the implementation and usage of handlers in various scenarios.</p>"},{"location":"reference/reference/#reference","title":"Reference","text":"<p>The reference page serves as a comprehensive guide to all modules, classes, and functions in the project. It is an exhaustive resource for understanding the project's API and architecture.</p>"},{"location":"reference/reference/#renderer","title":"Renderer","text":"<p>This section explains the rendering process, detailing how data is transformed and presented. It includes examples and best practices for implementing renderers.</p>"},{"location":"reference/reference/#test","title":"Test","text":"<p>The test documentation provides guidelines on how to write and run tests for the project. It includes details on testing frameworks, test coverage, and sample test cases.</p>"},{"location":"reference/reference/#utils","title":"Utils","text":"<p>This page describes the utility functions and helper modules available in the project. It covers common patterns and reusable components that assist in project development.</p>"},{"location":"reference/reference/#windows","title":"Windows","text":"<p>The windows documentation focuses on platform-specific considerations and implementations for Windows. It includes installation instructions, troubleshooting tips, and performance optimizations.</p>"},{"location":"reference/renderer/","title":"Renderer","text":""},{"location":"reference/renderer/#renderer","title":"Renderer","text":"<p>This module provides utilities for rendering data in various formats, specifically focusing on rendering Volatility framework data into JSON and pandas DataFrames.</p> <p>Classes:</p> Name Description <code>TreeGrid_to_json</code> <p>A class for rendering Volatility TreeGrid data into         JSON format.</p> <code>Renderer</code> <p>A class for rendering data into human-readable formats such         as lists, JSON strings, and pandas DataFrames.</p>"},{"location":"reference/renderer/#pydfirram.core.renderer.Renderer","title":"<code>Renderer</code>","text":"<p>Class for rendering data in various formats.</p> <p>This class provides methods to render data into human-readable formats such as lists, JSON strings, and pandas DataFrames.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>Any</code> <p>The input data to be rendered.</p> Source code in <code>pydfirram/core/renderer.py</code> <pre><code>class Renderer():\n    \"\"\"\n    Class for rendering data in various formats.\n\n    This class provides methods to render data into human-readable formats\n    such as lists, JSON strings, and pandas DataFrames.\n\n    Attributes:\n        data (Any): The input data to be rendered.\n    \"\"\"\n\n    def __init__(self, data: Any) -&gt; None:\n        \"\"\"\n        Initialize the Renderer with the provided data.\n\n        Args:\n            data (Any): The input data to be rendered.\n        \"\"\"\n        self.data = data\n\n    def to_list(self):\n        \"\"\"\n        Convert the data to a list format.\n\n        This method attempts to render the input data using the\n        TreeGrid_to_json class, and convert it to a dictionary.\n\n        Returns:\n            Dict: The rendered data in list format.\n\n        Raises:\n            Exception: If rendering the data fails.\n        \"\"\"\n        try:\n            # (fixme) : `render()` should return nothing\n            parsed_data : dict[str, Any] = TreeGrid_to_json().render(self.data)\n            return parsed_data.get(\"data\")\n        except Exception as e:\n            logger.error(\"Impossible to render data in dictionary form.\")\n            raise e\n\n    def file_render(self)-&gt; None:\n        \"\"\"\n        Convert the data to a list format.\n\n        This method attempts to render the input data using the\n        TreeGrid_to_json class, and convert it to a dictionary.\n\n        Returns:\n            Dict: The rendered data in list format.\n\n        Raises:\n            Exception: If rendering the data fails.\n        \"\"\"\n        try:\n            # (fixme) : `render()` return nothing\n            TreeGrid_to_json().render(self.data)\n        except Exception as e:\n            logger.error(\"Impossible to render data in dictionary form.\")\n            raise e\n\n    def to_json(self) -&gt; str:\n        \"\"\"\n        Convert the data to a JSON string.\n\n        This method first converts the data to a list format, and then\n        serializes it to a JSON string.\n\n        Returns:\n            str: The data serialized as a JSON string.\n\n        Raises:\n            Exception: If converting the data to JSON fails.\n        \"\"\"\n        try:\n            data_as_dict = self.to_list()\n            return dumps(data_as_dict)\n        except Exception as e:\n            logger.error(\"Unable to convert data to JSON.\")\n            raise e\n\n    def to_df(self,max_row: bool = False) -&gt; pd.DataFrame:\n        \"\"\"\n        Convert the data to a pandas DataFrame.\n\n        This method first converts the data to a list format, and then\n        constructs a pandas DataFrame from it.\n\n        Returns:\n            pd.DataFrame: The data as a pandas DataFrame.\n\n        Raises:\n            Exception: If rendering the data as a DataFrame fails.\n        \"\"\"\n        try:\n            data_as_dict = self.to_list()\n            if max_row:\n                pd.set_option('display.max_rows', None)\n                pd.set_option('display.max_columns', None)\n            return pd.DataFrame(data_as_dict)\n        except Exception as e:\n            logger.error(\"Data cannot be rendered as a DataFrame.\")\n            raise e\n</code></pre>"},{"location":"reference/renderer/#pydfirram.core.renderer.Renderer.__init__","title":"<code>__init__(data)</code>","text":"<p>Initialize the Renderer with the provided data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data to be rendered.</p> required Source code in <code>pydfirram/core/renderer.py</code> <pre><code>def __init__(self, data: Any) -&gt; None:\n    \"\"\"\n    Initialize the Renderer with the provided data.\n\n    Args:\n        data (Any): The input data to be rendered.\n    \"\"\"\n    self.data = data\n</code></pre>"},{"location":"reference/renderer/#pydfirram.core.renderer.Renderer.file_render","title":"<code>file_render()</code>","text":"<p>Convert the data to a list format.</p> <p>This method attempts to render the input data using the TreeGrid_to_json class, and convert it to a dictionary.</p> <p>Returns:</p> Name Type Description <code>Dict</code> <code>None</code> <p>The rendered data in list format.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If rendering the data fails.</p> Source code in <code>pydfirram/core/renderer.py</code> <pre><code>def file_render(self)-&gt; None:\n    \"\"\"\n    Convert the data to a list format.\n\n    This method attempts to render the input data using the\n    TreeGrid_to_json class, and convert it to a dictionary.\n\n    Returns:\n        Dict: The rendered data in list format.\n\n    Raises:\n        Exception: If rendering the data fails.\n    \"\"\"\n    try:\n        # (fixme) : `render()` return nothing\n        TreeGrid_to_json().render(self.data)\n    except Exception as e:\n        logger.error(\"Impossible to render data in dictionary form.\")\n        raise e\n</code></pre>"},{"location":"reference/renderer/#pydfirram.core.renderer.Renderer.to_df","title":"<code>to_df(max_row=False)</code>","text":"<p>Convert the data to a pandas DataFrame.</p> <p>This method first converts the data to a list format, and then constructs a pandas DataFrame from it.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: The data as a pandas DataFrame.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If rendering the data as a DataFrame fails.</p> Source code in <code>pydfirram/core/renderer.py</code> <pre><code>def to_df(self,max_row: bool = False) -&gt; pd.DataFrame:\n    \"\"\"\n    Convert the data to a pandas DataFrame.\n\n    This method first converts the data to a list format, and then\n    constructs a pandas DataFrame from it.\n\n    Returns:\n        pd.DataFrame: The data as a pandas DataFrame.\n\n    Raises:\n        Exception: If rendering the data as a DataFrame fails.\n    \"\"\"\n    try:\n        data_as_dict = self.to_list()\n        if max_row:\n            pd.set_option('display.max_rows', None)\n            pd.set_option('display.max_columns', None)\n        return pd.DataFrame(data_as_dict)\n    except Exception as e:\n        logger.error(\"Data cannot be rendered as a DataFrame.\")\n        raise e\n</code></pre>"},{"location":"reference/renderer/#pydfirram.core.renderer.Renderer.to_json","title":"<code>to_json()</code>","text":"<p>Convert the data to a JSON string.</p> <p>This method first converts the data to a list format, and then serializes it to a JSON string.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The data serialized as a JSON string.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If converting the data to JSON fails.</p> Source code in <code>pydfirram/core/renderer.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"\n    Convert the data to a JSON string.\n\n    This method first converts the data to a list format, and then\n    serializes it to a JSON string.\n\n    Returns:\n        str: The data serialized as a JSON string.\n\n    Raises:\n        Exception: If converting the data to JSON fails.\n    \"\"\"\n    try:\n        data_as_dict = self.to_list()\n        return dumps(data_as_dict)\n    except Exception as e:\n        logger.error(\"Unable to convert data to JSON.\")\n        raise e\n</code></pre>"},{"location":"reference/renderer/#pydfirram.core.renderer.Renderer.to_list","title":"<code>to_list()</code>","text":"<p>Convert the data to a list format.</p> <p>This method attempts to render the input data using the TreeGrid_to_json class, and convert it to a dictionary.</p> <p>Returns:</p> Name Type Description <code>Dict</code> <p>The rendered data in list format.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If rendering the data fails.</p> Source code in <code>pydfirram/core/renderer.py</code> <pre><code>def to_list(self):\n    \"\"\"\n    Convert the data to a list format.\n\n    This method attempts to render the input data using the\n    TreeGrid_to_json class, and convert it to a dictionary.\n\n    Returns:\n        Dict: The rendered data in list format.\n\n    Raises:\n        Exception: If rendering the data fails.\n    \"\"\"\n    try:\n        # (fixme) : `render()` should return nothing\n        parsed_data : dict[str, Any] = TreeGrid_to_json().render(self.data)\n        return parsed_data.get(\"data\")\n    except Exception as e:\n        logger.error(\"Impossible to render data in dictionary form.\")\n        raise e\n</code></pre>"},{"location":"reference/renderer/#pydfirram.core.renderer.TreeGrid_to_json","title":"<code>TreeGrid_to_json</code>","text":"<p>               Bases: <code>CLIRenderer</code></p> <p>simple TreeGrid to JSON</p> Source code in <code>pydfirram/core/renderer.py</code> <pre><code>class TreeGrid_to_json(V3CLIRenderer):  # type: ignore\n    \"\"\" simple TreeGrid to JSON\n    \"\"\"\n    _type_renderers: Any = {\n        V3HexBytes: lambda x: v3_quoted_optional(\n            v3_hex_bytes_as_text,\n        )(x),\n        V3Disassembly: lambda x: v3_quoted_optional(\n            v3_display_disassembly,\n        )(x),\n        V3MultiTypeData: lambda x: v3_quoted_optional(\n            v3_multitypedata_as_text,\n        )(x),\n        bytes: lambda x: v3_optional(\n            lambda x: \" \".join([f\"{b:02x}\" for b in x])\n        )(x),\n        datetime.datetime: lambda x: (\n            x.isoformat() if not isinstance(x, V3BaseAbsentValue) else None\n        ),\n        \"default\": lambda x: x,\n    }\n\n    name = \"JSON\"\n    structured_output = True\n\n    def get_render_options(self) -&gt; list[V3RenderOption]:\n        \"\"\"\n        Get render options.\n        \"\"\"\n        return []\n\n    # (fixme): This method should return nothing as defined in V3CLIRenderer\n    def render(self, grid: V3TreeGrid) -&gt; dict[str, Any]:\n        \"\"\"\n        Render the TreeGrid to JSON format.\n\n        Args:\n            grid (interfaces.renderers.TreeGrid): The TreeGrid to render.\n\n        Returns:\n            Dict: The JSON representation of the TreeGrid.\n        \"\"\"\n        final_output: tuple[\n            dict[str, dict[str, Any]],\n            list[dict[str, Any]],\n        ] = ({}, [])\n\n        def visitor(\n            node: V3TreeNode,\n            accumulator: tuple[dict[str, Any], list[dict[str, Any]]],\n        ) -&gt; tuple[dict[str, Any], list[dict[str, Any]]]:\n            \"\"\"\n            A visitor function to process each node in the TreeGrid.\n\n            Args:\n                node (V3TreeNode): The current node being visited.\n                accumulator (Tuple[Dict[str, Any], List[Dict[str, Any]]]):\n                    The accumulator containing the accumulated results.\n\n            Returns:\n                Tuple[Dict[str, Any], List[Dict[str, Any]]]: The updated\n                    accumulator.\n            \"\"\"\n            acc_map = accumulator[0]\n            final_tree = accumulator[1]\n            node_dict: dict[str, Any] = {\"__children\": []}\n\n            for column_index, column in enumerate(grid.columns):\n                renderer = self._type_renderers.get(\n                    column.type,\n                    self._type_renderers[\"default\"]\n                )\n                data = renderer(\n                    list(node.values)[column_index],\n                )\n                if isinstance(data, V3BaseAbsentValue):\n                    data = None\n                node_dict[column.name] = data\n\n            if node.parent:\n                acc_map[node.parent.path][\"__children\"].append(node_dict)\n            else:\n                final_tree.append(node_dict)\n            acc_map[node.path] = node_dict\n            return acc_map, final_tree\n\n        if not grid.populated:\n            grid.populate(visitor, final_output)\n        else:\n            grid.visit(\n                node=None,\n                function=visitor,\n                initial_accumulator=final_output,\n            )\n        return {\"data\": final_output[1]}\n</code></pre>"},{"location":"reference/renderer/#pydfirram.core.renderer.TreeGrid_to_json.get_render_options","title":"<code>get_render_options()</code>","text":"<p>Get render options.</p> Source code in <code>pydfirram/core/renderer.py</code> <pre><code>def get_render_options(self) -&gt; list[V3RenderOption]:\n    \"\"\"\n    Get render options.\n    \"\"\"\n    return []\n</code></pre>"},{"location":"reference/renderer/#pydfirram.core.renderer.TreeGrid_to_json.render","title":"<code>render(grid)</code>","text":"<p>Render the TreeGrid to JSON format.</p> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>TreeGrid</code> <p>The TreeGrid to render.</p> required <p>Returns:</p> Name Type Description <code>Dict</code> <code>dict[str, Any]</code> <p>The JSON representation of the TreeGrid.</p> Source code in <code>pydfirram/core/renderer.py</code> <pre><code>def render(self, grid: V3TreeGrid) -&gt; dict[str, Any]:\n    \"\"\"\n    Render the TreeGrid to JSON format.\n\n    Args:\n        grid (interfaces.renderers.TreeGrid): The TreeGrid to render.\n\n    Returns:\n        Dict: The JSON representation of the TreeGrid.\n    \"\"\"\n    final_output: tuple[\n        dict[str, dict[str, Any]],\n        list[dict[str, Any]],\n    ] = ({}, [])\n\n    def visitor(\n        node: V3TreeNode,\n        accumulator: tuple[dict[str, Any], list[dict[str, Any]]],\n    ) -&gt; tuple[dict[str, Any], list[dict[str, Any]]]:\n        \"\"\"\n        A visitor function to process each node in the TreeGrid.\n\n        Args:\n            node (V3TreeNode): The current node being visited.\n            accumulator (Tuple[Dict[str, Any], List[Dict[str, Any]]]):\n                The accumulator containing the accumulated results.\n\n        Returns:\n            Tuple[Dict[str, Any], List[Dict[str, Any]]]: The updated\n                accumulator.\n        \"\"\"\n        acc_map = accumulator[0]\n        final_tree = accumulator[1]\n        node_dict: dict[str, Any] = {\"__children\": []}\n\n        for column_index, column in enumerate(grid.columns):\n            renderer = self._type_renderers.get(\n                column.type,\n                self._type_renderers[\"default\"]\n            )\n            data = renderer(\n                list(node.values)[column_index],\n            )\n            if isinstance(data, V3BaseAbsentValue):\n                data = None\n            node_dict[column.name] = data\n\n        if node.parent:\n            acc_map[node.parent.path][\"__children\"].append(node_dict)\n        else:\n            final_tree.append(node_dict)\n        acc_map[node.path] = node_dict\n        return acc_map, final_tree\n\n    if not grid.populated:\n        grid.populate(visitor, final_output)\n    else:\n        grid.visit(\n            node=None,\n            function=visitor,\n            initial_accumulator=final_output,\n        )\n    return {\"data\": final_output[1]}\n</code></pre>"},{"location":"reference/utils/","title":"Utils","text":""},{"location":"reference/utils/#utils","title":"Utils","text":"<p>This module provides utilities for hashing files.</p> <p>Functions:</p> Name Description <code>get_hash</code> <p>Path) -&gt; str: Calculates and returns the SHA-256 hash of the specified file.</p>"},{"location":"reference/utils/#pydfirram.core.utils.get_hash","title":"<code>get_hash(path)</code>","text":"<p>Get the hash of a file.</p> <p>This method opens the specified file in binary mode and calculates the SHA-256 hash by traversing the file inblocks of 4096 bytes. The hash is updated at each iteration to include the contents of the processed block.</p> <p>Once the entire file has been processed, the method returns the SHA-256 hash value in hexadecimal format.</p> <p>Note: This method is intended for internal use by the specific code and must not be called directly from other parts of the code.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the file.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Hash of the file.</p> Source code in <code>pydfirram/core/utils.py</code> <pre><code>def get_hash(path: Path) -&gt; str:\n    \"\"\"\n    Get the hash of a file.\n\n    This method opens the specified file in binary mode and calculates the\n    SHA-256 hash by traversing the file inblocks of 4096 bytes. The hash is\n    updated at each iteration to include the contents of the processed block.\n\n    Once the entire file has been processed, the method returns the SHA-256\n    hash value in hexadecimal format.\n\n    Note: This method is intended for internal use by the specific code and\n    must not be called directly from other parts of the code.\n\n    Args:\n        path (Path): Path to the file.\n\n    Returns:\n        str: Hash of the file.\n    \"\"\"\n    with open(path, \"rb\") as f:\n        hash_obj = hashlib.sha256()\n        for chunk in iter(lambda: f.read(4096), b\"\"):\n            hash_obj.update(chunk)\n        return hash_obj.hexdigest()\n</code></pre>"},{"location":"reference/windows/","title":"Windows","text":""},{"location":"reference/windows/#windows","title":"Windows","text":"<p>Create generic volatility3 OS wrappers.</p> <p>This module provides a way to interact with Volatility3 plugins in a more abstract way. It allows to automatically get all available plugins for a specific OS and run them with the required arguments.</p> Example <p>The module can be used as follows:</p> <pre><code>$ python3\n&gt;&gt;&gt; from pydfirram.modules.windows import Windows\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; dumpfile = Path(\"tests/data/dump.raw\")\n&gt;&gt;&gt; generic = Windows(dumpfile)\n&gt;&gt;&gt; plugin = generic.pslist().to_list()\n</code></pre> <p>OR :     $ python3     &gt;&gt;&gt; from pydfirram.modules.windows import Windows     &gt;&gt;&gt; from pathlib import Path     &gt;&gt;&gt; dumpfile = Path(\"tests/data/dump.raw\")     &gt;&gt;&gt; generic = Windows(dumpfile)     &gt;&gt;&gt; plugin = generic.pslist(pid=[4]).to_df()     &gt;&gt;&gt; print(plugin)</p>"},{"location":"reference/windows/#pydfirram.modules.windows.Windows","title":"<code>Windows</code>","text":"<p>               Bases: <code>Generic</code></p> <p>A wrapper class for utilizing Windows-specific functionalities around the base methods.</p> <p>This class serves as a simplified interface for interacting with Windows operating system dumps. It inherits from the Generic class and initializes with Windows as the operating system.</p>"},{"location":"reference/windows/#pydfirram.modules.windows.Windows--attributes","title":"Attributes:","text":"<p>dumpfile : str     The path to the memory dump file.</p>"},{"location":"reference/windows/#pydfirram.modules.windows.Windows--methods","title":"Methods:","text":"<p>init(dumpfile)     Initializes the Windows class with the given dump file.</p> Source code in <code>pydfirram/modules/windows.py</code> <pre><code>class Windows(Generic):\n    \"\"\"\n    A wrapper class for utilizing Windows-specific functionalities around\n    the base methods.\n\n    This class serves as a simplified interface for interacting with\n    Windows operating system dumps. It inherits from the Generic class and\n    initializes with Windows as the operating system.\n\n    Attributes:\n    -----------\n    dumpfile : str\n        The path to the memory dump file.\n\n    Methods:\n    --------\n    __init__(dumpfile)\n        Initializes the Windows class with the given dump file.\n    \"\"\"\n    def __init__(self, dumpfile: str|Path) -&gt; None:\n        \"\"\"\n        Initializes the Windows class.\n\n        Parameters:\n        -----------\n        dumpfile : str\n            The path to the memory dump file.\n\n        Example:\n        --------\n        &gt;&gt;&gt; windows = Windows(\"path/to/dump.raw\": Path)\n        \"\"\"\n        if isinstance(dumpfile,str):\n            dumpfile = Path(dumpfile)\n        self.dump_files = dumpfile\n        super().__init__(\n            operating_system    = OperatingSystem.WINDOWS,\n            dump_file           = dumpfile,\n        )\n\n    # (todo) : seems to be a boilerplate from `Context`\n    # (todo) : add typing information\n    def _set_argument(self, context, prefix, kwargs):\n        for k, v in kwargs.items():\n            print(k,v)\n            context.config[prefix+k] = v\n        return context\n\n    def dumpfiles(self, **_kwargs: dict[str,Any]) -&gt; None:\n        \"\"\"\n            Dump memory files based on provided parameters.\n\n            This method utilizes the \"dumpfiles\" plugin to create memory\n            dumps from a Windows operating system context. The memory dumps\n            can be filtered based on the provided arguments. If no\n            parameters are provided, the method will dump the entire\n            system by default.\n\n            Parameters:\n            -----------\n            physaddr : int, optional\n                The physical address offset for the memory dump.\n            virtaddr : int, optional\n                The virtual address offset for the memory dump.\n            pid : int, optional\n                The process ID for which the memory dump should be\n                generated.\n\n            Notes:\n            ------\n            - The method sets up the context with the operating system\n                and dump files.\n            - Automagic and context settings are configured before\n                building the context.\n            - If additional keyword arguments are provided, they are\n                added as arguments to the context.\n            - The resulting context is executed and rendered to a file\n                using the Renderer class.\n            - If no parameters are provided, the method will dump the\n                entire system by default.\n\n            Returns:\n            --------\n            None\n            \"\"\"\n        plugin = self.get_plugin(\"dumpfiles\")\n        context = Context(\n            operating_system    = OperatingSystem.WINDOWS,\n            dump_file           = self.dump_files,\n            plugin              = plugin,\n        )\n        context.set_automagic()\n        context.set_context()\n        builded_context = context.build()\n        if _kwargs:\n            runable_context = context.add_arguments(builded_context,_kwargs)\n        else:\n            runable_context = builded_context\n        Renderer(runable_context.run()).file_render()\n</code></pre>"},{"location":"reference/windows/#pydfirram.modules.windows.Windows.__init__","title":"<code>__init__(dumpfile)</code>","text":"<p>Initializes the Windows class.</p>"},{"location":"reference/windows/#pydfirram.modules.windows.Windows.__init__--parameters","title":"Parameters:","text":"<p>dumpfile : str     The path to the memory dump file.</p>"},{"location":"reference/windows/#pydfirram.modules.windows.Windows.__init__--example","title":"Example:","text":"<p>windows = Windows(\"path/to/dump.raw\": Path)</p> Source code in <code>pydfirram/modules/windows.py</code> <pre><code>def __init__(self, dumpfile: str|Path) -&gt; None:\n    \"\"\"\n    Initializes the Windows class.\n\n    Parameters:\n    -----------\n    dumpfile : str\n        The path to the memory dump file.\n\n    Example:\n    --------\n    &gt;&gt;&gt; windows = Windows(\"path/to/dump.raw\": Path)\n    \"\"\"\n    if isinstance(dumpfile,str):\n        dumpfile = Path(dumpfile)\n    self.dump_files = dumpfile\n    super().__init__(\n        operating_system    = OperatingSystem.WINDOWS,\n        dump_file           = dumpfile,\n    )\n</code></pre>"},{"location":"reference/windows/#pydfirram.modules.windows.Windows.dumpfiles","title":"<code>dumpfiles(**_kwargs)</code>","text":"<p>Dump memory files based on provided parameters.</p> <p>This method utilizes the \"dumpfiles\" plugin to create memory dumps from a Windows operating system context. The memory dumps can be filtered based on the provided arguments. If no parameters are provided, the method will dump the entire system by default.</p>"},{"location":"reference/windows/#pydfirram.modules.windows.Windows.dumpfiles--parameters","title":"Parameters:","text":"<p>physaddr : int, optional     The physical address offset for the memory dump. virtaddr : int, optional     The virtual address offset for the memory dump. pid : int, optional     The process ID for which the memory dump should be     generated.</p>"},{"location":"reference/windows/#pydfirram.modules.windows.Windows.dumpfiles--notes","title":"Notes:","text":"<ul> <li>The method sets up the context with the operating system     and dump files.</li> <li>Automagic and context settings are configured before     building the context.</li> <li>If additional keyword arguments are provided, they are     added as arguments to the context.</li> <li>The resulting context is executed and rendered to a file     using the Renderer class.</li> <li>If no parameters are provided, the method will dump the     entire system by default.</li> </ul>"},{"location":"reference/windows/#pydfirram.modules.windows.Windows.dumpfiles--returns","title":"Returns:","text":"<p>None</p> Source code in <code>pydfirram/modules/windows.py</code> <pre><code>def dumpfiles(self, **_kwargs: dict[str,Any]) -&gt; None:\n    \"\"\"\n        Dump memory files based on provided parameters.\n\n        This method utilizes the \"dumpfiles\" plugin to create memory\n        dumps from a Windows operating system context. The memory dumps\n        can be filtered based on the provided arguments. If no\n        parameters are provided, the method will dump the entire\n        system by default.\n\n        Parameters:\n        -----------\n        physaddr : int, optional\n            The physical address offset for the memory dump.\n        virtaddr : int, optional\n            The virtual address offset for the memory dump.\n        pid : int, optional\n            The process ID for which the memory dump should be\n            generated.\n\n        Notes:\n        ------\n        - The method sets up the context with the operating system\n            and dump files.\n        - Automagic and context settings are configured before\n            building the context.\n        - If additional keyword arguments are provided, they are\n            added as arguments to the context.\n        - The resulting context is executed and rendered to a file\n            using the Renderer class.\n        - If no parameters are provided, the method will dump the\n            entire system by default.\n\n        Returns:\n        --------\n        None\n        \"\"\"\n    plugin = self.get_plugin(\"dumpfiles\")\n    context = Context(\n        operating_system    = OperatingSystem.WINDOWS,\n        dump_file           = self.dump_files,\n        plugin              = plugin,\n    )\n    context.set_automagic()\n    context.set_context()\n    builded_context = context.build()\n    if _kwargs:\n        runable_context = context.add_arguments(builded_context,_kwargs)\n    else:\n        runable_context = builded_context\n    Renderer(runable_context.run()).file_render()\n</code></pre>"},{"location":"tutorials/installation/","title":"Installation","text":""},{"location":"tutorials/installation/#quick-installation-guide","title":"Quick Installation Guide","text":"<p>This guide provides instructions for installing <code>pydfirram</code> from various sources and using all plugins available in the <code>volatility3</code> repository.</p>"},{"location":"tutorials/installation/#prerequisites","title":"Prerequisites","text":"<p>Ensure you have the following installed:</p> <ul> <li>Python</li> <li>Poetry (for development)</li> <li>pip</li> </ul>"},{"location":"tutorials/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"tutorials/installation/#from-source","title":"From Source","text":"<p>To install <code>pydfirram</code> from the source on a standard Linux distribution, follow these steps:</p> <ol> <li> <p>Clone the repository:     <pre><code>git clone https://github.com/pydfir/pydfirram\n</code></pre></p> </li> <li> <p>Navigate into the project directory:     <pre><code>cd pydfirram\n</code></pre></p> </li> <li> <p>Create a virtual environment and activate it using Poetry:     <pre><code>poetry shell\n</code></pre></p> </li> <li> <p>Install the dependencies:     <pre><code>poetry install\n</code></pre></p> </li> </ol>"},{"location":"tutorials/installation/#from-pip-stable","title":"From pip (Stable)","text":"<p>To install the stable version of <code>pydfirram</code> from pip, use the following command:</p> <pre><code>pip install pydfirram\n</code></pre>"},{"location":"tutorials/installation/#from-pip-development","title":"From pip (Development)","text":"<p>To install the development version of <code>pydfirram</code> from the TestPyPI repository, use the following command:</p> <pre><code>pip install -i https://test.pypi.org/simple/ pydfirram\n</code></pre>"},{"location":"tutorials/installation/#using-all-plugins","title":"Using All Plugins","text":"<p>To use all plugins available in the <code>volatility3</code> repository, follow these steps:</p> <ol> <li> <p>Install <code>pydfirram</code>:     <pre><code>pip install pydfirram\n</code></pre></p> </li> <li> <p>Clone the <code>volatility3</code> repository:     <pre><code>git clone https://github.com/volatilityfoundation/volatility3\n</code></pre></p> </li> <li> <p>Navigate into the <code>volatility3</code> directory:     <pre><code>cd volatility3\n</code></pre></p> </li> <li> <p>Install the plugins:     <pre><code>pip install .\n</code></pre></p> </li> </ol> <p>This setup ensures that you have access to all the plugins provided by the <code>volatility3</code> repository.</p>"},{"location":"tutorials/linux/","title":"Linux/Mac","text":""},{"location":"tutorials/linux/#using-pydfirram-for-linux-or-macos","title":"Using pyDFIRRam for Linux or macOS","text":""},{"location":"tutorials/linux/#introduction","title":"Introduction","text":"<p><code>pyDFIRRam</code> is a tool under development aimed at utilizing Volatility plugins for memory forensics on Linux and macOS systems.</p>"},{"location":"tutorials/linux/#initial-setup","title":"Initial Setup","text":"<ol> <li>Installation:</li> <li>Ensure Python 3.10 (or compatible version) is installed.</li> <li> <p>Install <code>pyDFIRRam</code> using Poetry or manually. Example:      <pre><code>pip install pydfirram\n</code></pre></p> </li> <li> <p>Setting up a Profile:</p> </li> <li>Currently, there's no direct method via Python interface to add a profile. If you have a profile, place it in the Volatility symbols directory:<ul> <li>For Linux/macOS:    <pre><code>$HOME/.local/lib/python3.10/site-packages/volatility3/symbols/\n</code></pre></li> <li>For Poetry virtual environments:    <pre><code>$HOME/.cache/pypoetry/virtualenvs/pydfirram-qv9SWnlF-py3.10/lib/python3.10/site-packages/volatility3/symbols/\n</code></pre></li> </ul> </li> </ol>"},{"location":"tutorials/linux/#using-pydfirram","title":"Using pyDFIRRam","text":"<ol> <li>Creating an Object:</li> <li> <p>Import necessary modules and create an object for your memory dump:      <pre><code>from pydfirram.core.base import Generic, OperatingSystem\nfrom pathlib import Path\n\nos = OperatingSystem.LINUX  # Set to OperatingSystem.MACOS for macOS\ndumpfile = Path(\"dump.raw\")  # Replace with your actual memory dump path\ngeneric = Generic(os, dumpfile)\n</code></pre></p> </li> <li> <p>Listing Available Functions:</p> </li> <li> <p>To list all available Volatility plugins:      <pre><code>generic.get_all_plugins()\n</code></pre></p> </li> <li> <p>Using Plugins:</p> </li> <li> <p>Refer to Volatility plugin documentation for parameters. Example using <code>pslist</code> plugin:      <pre><code>generic.pslist(pid=[4]).to_list()\n</code></pre></p> </li> <li> <p>Formatting Output:</p> </li> <li>The return from Volatility functions provides a <code>Rendering</code> class, allowing customization of output format.</li> </ol>"},{"location":"tutorials/linux/#notes","title":"Notes","text":"<ul> <li>Ensure your memory dump file (<code>dump.raw</code> in the example) is correctly specified.</li> <li>Adjust paths and settings based on your specific environment and Python setup.</li> </ul>"},{"location":"tutorials/windows/","title":"How to Use pyDFIRRam for Windows","text":"<p>This guide provides a brief and concise demonstration of how to use the pyDFIRRam tool for Windows.</p>"},{"location":"tutorials/windows/#introduction","title":"Introduction","text":"<p>Currently, the project is under development. To use the Volatility-related functions for Windows, follow these steps:</p>"},{"location":"tutorials/windows/#initial-setup","title":"Initial Setup","text":"<p>First, create an object for your memory dump:</p> <pre><code>from pydfirram.modules.windows import Windows\nfrom pathlib import Path\n\ndump = Path(\"/home/dev/image.dump\")\nwin = Windows(dump)\n</code></pre>"},{"location":"tutorials/windows/#listing-available-functions","title":"Listing Available Functions","text":"<p>The available functions are all the Volatility plugins (located in the Volatility plugin path).</p> <p>To list all available functions:</p> <pre><code>win.get_all_plugins()\n</code></pre> <p>You can use this function to retrieve all the plugins.</p>"},{"location":"tutorials/windows/#using-parameters","title":"Using Parameters","text":"<p>If you want to use Volatility parameters, refer to the plugin documentation. The parameters expected are generally the same with the same names.</p> <p>For example, to use the <code>pslist</code> plugin with a parameter:</p> <pre><code>win.pslist(pid=4).to_list()\n</code></pre>"},{"location":"tutorials/windows/#note","title":"Note","text":"<p>On the return of the Volatility functions, a <code>Rendering</code> class is retrieved. This allows us to format our output as desired.</p>"}]}